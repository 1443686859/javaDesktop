//给你一个有 n 个服务器的计算机网络，服务器编号为 0 到 n - 1 。同时给你一个二维整数数组 edges ，其中 edges[i] = [ui, 
//vi] 表示服务器 ui 和 vi 之间有一条信息线路，在 一秒 内它们之间可以传输 任意 数目的信息。再给你一个长度为 n 且下标从 0 开始的整数数组 
//patience 。 
//
// 题目保证所有服务器都是 相通 的，也就是说一个信息从任意服务器出发，都可以通过这些信息线路直接或间接地到达任何其他服务器。 
//
// 编号为 0 的服务器是 主 服务器，其他服务器为 数据 服务器。每个数据服务器都要向主服务器发送信息，并等待回复。信息在服务器之间按 最优 线路传输，也就
//是说每个信息都会以 最少时间 到达主服务器。主服务器会处理 所有 新到达的信息并 立即 按照每条信息来时的路线 反方向 发送回复信息。 
//
// 在 0 秒的开始，所有数据服务器都会发送各自需要处理的信息。从第 1 秒开始，每 一秒最 开始 时，每个数据服务器都会检查它是否收到了主服务器的回复信息（
//包括新发出信息的回复信息）： 
//
// 
// 如果还没收到任何回复信息，那么该服务器会周期性 重发 信息。数据服务器 i 每 patience[i] 秒都会重发一条信息，也就是说，数据服务器 i 在上
//一次发送信息给主服务器后的 patience[i] 秒 后 会重发一条信息给主服务器。 
// 否则，该数据服务器 不会重发 信息。 
// 
//
// 当没有任何信息在线路上传输或者到达某服务器时，该计算机网络变为 空闲 状态。 
//
// 请返回计算机网络变为 空闲 状态的 最早秒数 。 
//
// 
//
// 示例 1： 
//
// 
//
// 输入：edges = [[0,1],[1,2]], patience = [0,2,1]
//输出：8
//解释：
//0 秒最开始时，
//- 数据服务器 1 给主服务器发出信息（用 1A 表示）。
//- 数据服务器 2 给主服务器发出信息（用 2A 表示）。
//
//1 秒时，
//- 信息 1A 到达主服务器，主服务器立刻处理信息 1A 并发出 1A 的回复信息。
//- 数据服务器 1 还没收到任何回复。距离上次发出信息过去了 1 秒（1 < patience[1] = 2），所以不会重发信息。
//- 数据服务器 2 还没收到任何回复。距离上次发出信息过去了 1 秒（1 == patience[2] = 1），所以它重发一条信息（用 2B 表示）。
//
//2 秒时，
//- 回复信息 1A 到达服务器 1 ，服务器 1 不会再重发信息。
//- 信息 2A 到达主服务器，主服务器立刻处理信息 2A 并发出 2A 的回复信息。
//- 服务器 2 重发一条信息（用 2C 表示）。
//...
//4 秒时，
//- 回复信息 2A 到达服务器 2 ，服务器 2 不会再重发信息。
//...
//7 秒时，回复信息 2D 到达服务器 2 。
//
//从第 8 秒开始，不再有任何信息在服务器之间传输，也不再有信息到达服务器。
//所以第 8 秒是网络变空闲的最早时刻。
// 
//
// 示例 2： 
//
// 
//
// 输入：edges = [[0,1],[0,2],[1,2]], patience = [0,10,10]
//输出：3
//解释：数据服务器 1 和 2 第 2 秒初收到回复信息。
//从第 3 秒开始，网络变空闲。
// 
//
// 
//
// 提示： 
//
// 
// n == patience.length 
// 2 <= n <= 10⁵ 
// patience[0] == 0 
// 对于 1 <= i < n ，满足 1 <= patience[i] <= 10⁵ 
// 1 <= edges.length <= min(10⁵, n * (n - 1) / 2) 
// edges[i].length == 2 
// 0 <= ui, vi < n 
// ui != vi 
// 不会有重边。 
// 每个服务器都直接或间接与别的服务器相连。 
// 
// 👍 2 👎 0


package leetcode.editor.cn;

import java.util.*;

//Java：网络空闲的时刻
public class T2039_TheTimeWhenTheNetworkBecomesIdle{
    public static void main(String[] args) {
        Solution solution = new T2039_TheTimeWhenTheNetworkBecomesIdle().new Solution();
        // TO TEST
        System.out.println(solution.networkBecomesIdle(new int[][]
                {{34,90},{82,5},{184,178},{92,32},{125,98},{149,134},{120,154},{37,129},{30,180},{161,2},{116,20},{42,12},{62,73},{96,162},{174,31},{124,101},{43,82},{87,59},{127,137},{103,7},{58,14},{119,133},{1,15},{84,113},{164,122},{128,104},{141,36},{81,166},{170,182},{89,30},{85,84},{109,1},{28,70},{83,102},{117,60},{31,169},{159,76},{146,67},{151,58},{23,34},{148,184},{179,19},{123,115},{70,21},{78,33},{99,26},{155,71},{104,100},{16,151},{72,147},{95,124},{13,138},{133,53},{60,116},{173,63},{29,56},{80,120},{17,43},{55,110},{6,119},{154,143},{51,172},{14,39},{112,38},{39,32},{35,132},{98,159},{160,107},{73,65},{183,27},{177,78},{136,46},{18,75},{27,91},{71,163},{100,77},{122,51},{178,45},{52,55},{59,160},{12,114},{38,42},{113,4},{163,167},{171,131},{167,183},{7,37},{102,54},{91,156},{40,92},{139,74},{142,145},{147,62},{0,128},{66,165},{111,175},{107,16},{22,80},{92,53},{94,86},{153,24},{74,3},{165,108},{176,130},{181,177},{67,95},{144,117},{15,135},{57,93},{145,8},{8,48},{26,127},{36,171},{126,40},{168,157},{108,121},{56,109},{65,88},{169,35},{130,181},{110,9},{2,22},{137,87},{152,118},{182,174},{53,32},{79,10},{114,47},{63,161},{0,94},{0,32},{76,150},{131,112},{129,105},{121,168},{118,111},{68,83},{69,61},{5,173},{172,149},{20,179},{162,57},{21,158},{166,11},{105,139},{93,44},{97,79},{106,23},{47,123},{46,49},{77,50},{157,153},{138,126},{0,69},{88,97},{24,68},{156,176},{92,39},{48,41},{158,170},{86,146},{61,142},{54,125},{19,148},{175,52},{44,85},{9,103},{135,144},{33,152},{90,66},{140,6},{101,28},{143,136},{75,96},{41,155},{53,39},{115,140},{150,13},{134,72},{180,164},{64,81},{45,106},{49,141},{50,89},{4,99},{11,25},{10,64},{25,17},{3,18},{132,29}},
                new int[]{0,5,4,6,8,6,10,3,11,1,9,1,9,13,9,9,12,3,6,7,2,5,1,4,7,4,18,10,7,9,16,1,24,1,5,15,5,8,11,2,27,4,10,1,3,4,3,8,1,10,12,21,3,2,17,1,1,1,5,3,4,29,11,2,4,2,9,9,12,9,2,10,9,7,5,7,9,3,10,2,7,4,8,3,12,4,16,6,4,22,6,13,20,1,2,8,1,2,5,16,29,16,5,1,27,2,5,22,1,6,4,5,7,5,15,5,4,5,4,6,8,5,8,24,23,17,7,8,3,1,7,5,2,17,4,5,11,9,16,1,12,13,26,1,7,4,18,1,7,12,19,12,1,10,3,3,14,8,15,19,22,1,4,22,14,1,4,1,11,11,13,2,2,1,1,7,8,2,2,1,15,3,4,19,1}));
    }
    //leetcode submit region begin(Prohibit modification and deletion)
class Solution {
    public int networkBecomesIdle(int[][] edges, int[] patience) {
        int n = patience.length;
        Map<Integer, Set<Integer>> edgeMap = new HashMap<>();
        for (int[] edge : edges) {
            int x = edge[0];
            int y = edge[1];
            edgeMap.putIfAbsent(x, new HashSet<>());
            edgeMap.putIfAbsent(y, new HashSet<>());
            edgeMap.get(y).add(x);
            edgeMap.get(x).add(y);
        }
        Queue<Integer> queue = new LinkedList<>();
        int[] distance = new int[n];
        for (int i = 1; i < n; i++) {
            distance[i] = Integer.MAX_VALUE;
        }
        queue.offer(0);
        int step = 0;
        while (!queue.isEmpty()) {
            Set<Integer> currentSet = new HashSet<>();
            step++;
            while (!queue.isEmpty()) {
                int start = queue.poll();
                for (int i : edgeMap.getOrDefault(start, new HashSet<>())) {
                    if (distance[i] == Integer.MAX_VALUE) {
                        distance[i] = Math.min(distance[i], step);
                        currentSet.add(i);
                    }

                }
            }
            for (int i : currentSet) {
                queue.offer(i);
            }
        }
        int max = 0;
        int[] result = new int[n];
        for (int i = 1; i < n; i++) {
            int time = 2 * distance[i] / patience[i] +  ((2* distance[i]) % patience[i] > 0 ? 1 : 0);
            result[i] = (time - 1) * patience[i] + 2 * distance[i];
            max = Math.max(max, result[i]);
        }
        return max + 1;
    }
}
//leetcode submit region end(Prohibit modification and deletion)

}