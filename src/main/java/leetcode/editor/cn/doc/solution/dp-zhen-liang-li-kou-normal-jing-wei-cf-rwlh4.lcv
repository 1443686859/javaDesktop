## 题解

本题是一道 [CF 原题](https://codeforces.com/contest/1552/problem/F) 的简化版，有兴趣的朋友可以挑战一下原题看看（CF 2200 分的题是力扣 normal 什么的真的没问题吗）。

由于每次只会前进一个房间或后退到之前的某个房间中，因此每个房间第一次被访问的时间一定是递增的。另外由于只有偶数次访问时才能前进一个房间，所以当我们到达房间 $i$ 后，前面第 $0$ 至 $(i - 1)$ 的房间目前一定都被访问偶数次。

考虑当奇数次进入房间 $i$ 后会发生什么。我们会后退到房间 $r_i$，而后退之前，房间 $r_i$ 至房间 $(i - 1)$ 都已经被访问了偶数次。因此我们会奇数次访问 $r_i$，经过一定步骤后再次（偶数次）访问 $r_i$，然后奇数次访问 $(r_i + 1)$，经过一定步骤后再次（偶数次）访问 $(r_i + 1)$... 直到我们再次（偶数次）访问 $i$。

分析到这里 dp 方程就很清晰了，记 $f_i$ 表示第一次进入房间 $i$ 需要几天，$g_i$ 表示奇数次访问房间 $i$ 并离开后，再次（偶数次）访问房间 $i$ 需要几天。dp 方程为
* $f_i = f_{i - 1} + g_i + 1$ // 为了第一次进入房间 $i$，需要访问房间 $(i - 1)$ 两次。
* $g_i = i - r_i + 1 + \sum\limits_{j = r_i}^{i - 1} g_j$ // 为了回到房间 $i$，需要把房间 $r_i$ 至 $(i - 1)$ 都变成奇数次再变成偶数次。房间 $j$ 先从偶数次变奇数次只要从上个房间走一步进来即可，从奇数次再变成偶数次需要 $g_j$ 步。

求和部分记个前缀和即可。复杂度 $\mathcal{O}(n)$。

## 代码

* cpp

```cpp
class Solution {
    const int MOD = 1000000007;
    long long f[100010][2], g[100010];
    
public:
    int firstDayBeenInAllRooms(vector<int>& nextVisit) {
        int n = nextVisit.size();
        for (int i = 1; i <= n; i++) {
            f[i][1] = (f[i - 1][1] + f[i - 1][0] + 1) % MOD;
            f[i][0] = (g[i - 1] - g[nextVisit[i - 1]] + MOD + i - nextVisit[i - 1]) % MOD;
            g[i] = (g[i - 1] + f[i][0]) % MOD;
        }
        return (f[n][1] - 1 + MOD) % MOD;
    }
};
```

