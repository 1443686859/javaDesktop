**æ–¹æ³•ä¸€ï¼šçŠ¶æ€åŽ‹ç¼© + åŠ¨æ€è§„åˆ’**

æˆ‘ä»¬è®°ç¬¬ä¸€ç»„çš„ç‚¹æ•°ä¸º $m$ï¼Œç¬¬äºŒç»„çš„ç‚¹æ•°ä¸º $n$ã€‚

ç”±äºŽ $1 \leq n \leq m \leq 12$ï¼Œå› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ªæ•´æ•°æ¥è¡¨ç¤ºç¬¬äºŒç»„ä¸­ç‚¹çš„çŠ¶æ€ï¼Œå³äºŒè¿›åˆ¶è¡¨ç¤ºçš„ä¸€ä¸ªé•¿åº¦ä¸º $n$ çš„æ•´æ•°ï¼Œå…¶ä¸­ç¬¬ $k$ ä½ä¸º $1$ è¡¨ç¤ºç¬¬äºŒç»„ä¸­çš„ç¬¬ $k$ ä¸ªç‚¹ä¸Žç¬¬ä¸€ç»„ä¸­çš„ç‚¹è¿žé€šï¼Œä¸º $0$ è¡¨ç¤ºä¸è¿žé€šã€‚

æŽ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å®šä¹‰ $f[i][j]$ è¡¨ç¤ºç¬¬ä¸€ç»„ä¸­çš„å‰ $i$ ä¸ªç‚¹å·²ç»å…¨éƒ¨è¿žé€šï¼Œä¸”ç¬¬äºŒç»„ä¸­çš„ç‚¹çš„çŠ¶æ€ä¸º $j$ æ—¶çš„æœ€å°æˆæœ¬ã€‚åˆå§‹æ—¶ $f[0][0] = 0$ï¼Œå…¶ä½™å€¼å‡ä¸ºæ­£æ— ç©·å¤§ã€‚ç­”æ¡ˆå³ä¸º $f[m][2^n - 1]$ã€‚

è€ƒè™‘ $f[i][j]$ï¼Œå…¶ä¸­ $i \geq 1$ã€‚æˆ‘ä»¬å¯ä»¥æžšä¸¾ç¬¬äºŒç»„ä¸­çš„æ¯ä¸ªç‚¹ $k$ï¼Œå¦‚æžœç‚¹ $k$ ä¸Žç¬¬ä¸€ç»„ä¸­çš„ç¬¬ $i$ ä¸ªç‚¹è¿žé€šï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥åˆ†ä»¥ä¸‹ä¸¤ç§æƒ…å†µè®¨è®ºï¼š

- å¦‚æžœç‚¹ $k$ åªä¸Žç¬¬ä¸€ç»„ä¸­çš„ç¬¬ $i$ ä¸ªç‚¹è¿žé€šï¼Œé‚£ä¹ˆ $f[i][j]$ å¯ä»¥ä»Ž $f[i][j \oplus 2^k]$ æˆ–è€… $f[i - 1][j \oplus 2^k]$ è½¬ç§»è€Œæ¥ï¼Œå…¶ä¸­ $\oplus$ è¡¨ç¤ºå¼‚æˆ–è¿ç®—ï¼›
- å¦‚æžœç‚¹ $k$ ä¸Žç¬¬ä¸€ç»„ä¸­çš„ç¬¬ $i$ ä¸ªç‚¹ä»¥åŠå…¶ä»–ç‚¹éƒ½è¿žé€šï¼Œé‚£ä¹ˆ $f[i][j]$ å¯ä»¥ä»Ž $f[i - 1][j]$ è½¬ç§»è€Œæ¥ã€‚

åœ¨ä¸Šè¿°ä¸¤ç§æƒ…å†µä¸­ï¼Œæˆ‘ä»¬éœ€è¦é€‰æ‹©è½¬ç§»å€¼æœ€å°çš„é‚£ä¸ªï¼Œå³æœ‰ï¼š

$$
f[i][j] = \min_{k \in \{0, 1, \cdots, n - 1\}} \{f[i][j \oplus 2^k], f[i - 1][j \oplus 2^k], f[i - 1][j]\} + cost[i - 1][k]
$$

æœ€åŽï¼Œæˆ‘ä»¬è¿”å›ž $f[m][2^n - 1]$ å³å¯ã€‚

* [sol1-Python3]

```python
class Solution:
    def connectTwoGroups(self, cost: List[List[int]]) -> int:
        m, n = len(cost), len(cost[0])
        f = [[inf] * (1 << n) for _ in range(m + 1)]
        f[0][0] = 0
        for i in range(1, m + 1):
            for j in range(1 << n):
                for k in range(n):
                    if (j >> k & 1) == 0:
                        continue
                    c = cost[i - 1][k]
                    x = min(f[i][j ^ (1 << k)], f[i - 1][j], f[i - 1][j ^ (1 << k)]) + c
                    f[i][j] = min(f[i][j], x)
        return f[m][-1]
```

* [sol1-Java]

```java
class Solution {
    public int connectTwoGroups(List<List<Integer>> cost) {
        int m = cost.size(), n = cost.get(0).size();
        final int inf = 1 << 30;
        int[][] f = new int[m + 1][1 << n];
        for (int[] g : f) {
            Arrays.fill(g, inf);
        }
        f[0][0] = 0;
        for (int i = 1; i <= m; ++i) {
            for (int j = 0; j < 1 << n; ++j) {
                for (int k = 0; k < n; ++k) {
                    if ((j >> k & 1) == 1) {
                        int c = cost.get(i - 1).get(k);
                        f[i][j] = Math.min(f[i][j], f[i][j ^ (1 << k)] + c);
                        f[i][j] = Math.min(f[i][j], f[i - 1][j] + c);
                        f[i][j] = Math.min(f[i][j], f[i - 1][j ^ (1 << k)] + c);
                    }
                }
            }
        }
        return f[m][(1 << n) - 1];
    }
}
```

* [sol1-C++]

```cpp
class Solution {
public:
    int connectTwoGroups(vector<vector<int>>& cost) {
        int m = cost.size(), n = cost[0].size();
        int f[m + 1][1 << n];
        memset(f, 0x3f, sizeof(f));
        f[0][0] = 0;
        for (int i = 1; i <= m; ++i) {
            for (int j = 0; j < 1 << n; ++j) {
                for (int k = 0; k < n; ++k) {
                    if (j >> k & 1) {
                        int c = cost[i - 1][k];
                        int x = min({f[i][j ^ (1 << k)], f[i - 1][j], f[i - 1][j ^ (1 << k)]}) + c;
                        f[i][j] = min(f[i][j], x);
                    }
                }
            }
        }
        return f[m][(1 << n) - 1];
    }
};
```

* [sol1-Go]

```go
func connectTwoGroups(cost [][]int) int {
	m, n := len(cost), len(cost[0])
	const inf = 1 << 30
	f := make([][]int, m+1)
	for i := range f {
		f[i] = make([]int, 1<<n)
		for j := range f[i] {
			f[i][j] = inf
		}
	}
	f[0][0] = 0
	for i := 1; i <= m; i++ {
		for j := 0; j < 1<<n; j++ {
			for k := 0; k < n; k++ {
				c := cost[i-1][k]
				if j>>k&1 == 1 {
					f[i][j] = min(f[i][j], f[i][j^(1<<k)]+c)
					f[i][j] = min(f[i][j], f[i-1][j]+c)
					f[i][j] = min(f[i][j], f[i-1][j^(1<<k)]+c)
				}
			}
		}
	}
	return f[m][(1<<n)-1]
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
```

* [sol1-TypeScript]

```ts
function connectTwoGroups(cost: number[][]): number {
    const m = cost.length;
    const n = cost[0].length;
    const inf = 1 << 30;
    const f: number[][] = Array(m + 1)
        .fill(0)
        .map(() => Array(1 << n).fill(inf));
    f[0][0] = 0;
    for (let i = 1; i <= m; ++i) {
        for (let j = 0; j < 1 << n; ++j) {
            for (let k = 0; k < n; ++k) {
                if (((j >> k) & 1) === 1) {
                    const c = cost[i - 1][k];
                    f[i][j] = Math.min(f[i][j], f[i][j ^ (1 << k)] + c);
                    f[i][j] = Math.min(f[i][j], f[i - 1][j] + c);
                    f[i][j] = Math.min(f[i][j], f[i - 1][j ^ (1 << k)] + c);
                }
            }
        }
    }
    return f[m][(1 << n) - 1];
}
```

æ—¶é—´å¤æ‚åº¦ $O(m \times n \times 2^n)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(m \times 2^n)$ã€‚å…¶ä¸­ $m$ å’Œ $n$ åˆ†åˆ«æ˜¯ç¬¬ä¸€ç»„å’Œç¬¬äºŒç»„ä¸­çš„ç‚¹æ•°ã€‚

æˆ‘ä»¬æ³¨æ„åˆ° $f[i][j]$ çš„è½¬ç§»åªä¸Ž $f[i - 1][\cdot]$ ä»¥åŠ $f[i][\cdot]$ æœ‰å…³ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ»šåŠ¨æ•°ç»„ä¼˜åŒ–ç©ºé—´å¤æ‚åº¦ï¼Œå°†ç©ºé—´å¤æ‚åº¦ä¼˜åŒ–åˆ° $O(2^n)$ã€‚

* [sol2-Python3]

```python
class Solution:
    def connectTwoGroups(self, cost: List[List[int]]) -> int:
        m, n = len(cost), len(cost[0])
        f = [inf] * (1 << n)
        f[0] = 0
        g = f[:]
        for i in range(1, m + 1):
            for j in range(1 << n):
                g[j] = inf
                for k in range(n):
                    if (j >> k & 1) == 0:
                        continue
                    c = cost[i - 1][k]
                    x = min(g[j ^ (1 << k)], f[j], f[j ^ (1 << k)]) + c
                    g[j] = min(g[j], x)
            f = g[:]
        return f[-1]
```

* [sol2-Java]

```java
class Solution {
    public int connectTwoGroups(List<List<Integer>> cost) {
        int m = cost.size(), n = cost.get(0).size();
        final int inf = 1 << 30;
        int[] f = new int[1 << n];
        Arrays.fill(f, inf);
        f[0] = 0;
        int[] g = f.clone();
        for (int i = 1; i <= m; ++i) {
            for (int j = 0; j < 1 << n; ++j) {
                g[j] = inf;
                for (int k = 0; k < n; ++k) {
                    if ((j >> k & 1) == 1) {
                        int c = cost.get(i - 1).get(k);
                        g[j] = Math.min(g[j], g[j ^ (1 << k)] + c);
                        g[j] = Math.min(g[j], f[j] + c);
                        g[j] = Math.min(g[j], f[j ^ (1 << k)] + c);
                    }
                }
            }
            System.arraycopy(g, 0, f, 0, 1 << n);
        }
        return f[(1 << n) - 1];
    }
}
```

* [sol2-C++]

```cpp
class Solution {
public:
    int connectTwoGroups(vector<vector<int>>& cost) {
        int m = cost.size(), n = cost[0].size();
        const int inf = 1 << 30;
        vector<int> f(1 << n, inf);
        f[0] = 0;
        vector<int> g = f;
        for (int i = 1; i <= m; ++i) {
            for (int j = 0; j < 1 << n; ++j) {
                g[j] = inf;
                for (int k = 0; k < n; ++k) {
                    if (j >> k & 1) {
                        int c = cost[i - 1][k];
                        int x = min({g[j ^ (1 << k)], f[j], f[j ^ (1 << k)]}) + c;
                        g[j] = min(g[j], x);
                    }
                }
            }
            f.swap(g);
        }
        return f[(1 << n) - 1];
    }
};
```

* [sol2-Go]

```go
func connectTwoGroups(cost [][]int) int {
	m, n := len(cost), len(cost[0])
	const inf = 1 << 30
	f := make([]int, 1<<n)
	for i := range f {
		f[i] = inf
	}
	f[0] = 0
	g := make([]int, 1<<n)
	for i := 1; i <= m; i++ {
		for j := 0; j < 1<<n; j++ {
			g[j] = inf
			for k := 0; k < n; k++ {
				c := cost[i-1][k]
				if j>>k&1 == 1 {
					g[j] = min(g[j], g[j^1<<k]+c)
					g[j] = min(g[j], f[j]+c)
					g[j] = min(g[j], f[j^1<<k]+c)
				}
			}
		}
		copy(f, g)
	}
	return f[1<<n-1]
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
```

* [sol2-TypeScript]

```ts
function connectTwoGroups(cost: number[][]): number {
    const m = cost.length;
    const n = cost[0].length;
    const inf = 1 << 30;
    const f: number[] = new Array(1 << n).fill(inf);
    f[0] = 0;
    const g = new Array(1 << n).fill(0);
    for (let i = 1; i <= m; ++i) {
        for (let j = 0; j < 1 << n; ++j) {
            g[j] = inf;
            for (let k = 0; k < n; ++k) {
                if (((j >> k) & 1) === 1) {
                    const c = cost[i - 1][k];
                    g[j] = Math.min(g[j], g[j ^ (1 << k)] + c);
                    g[j] = Math.min(g[j], f[j] + c);
                    g[j] = Math.min(g[j], f[j ^ (1 << k)] + c);
                }
            }
        }
        f.splice(0, f.length, ...g);
    }
    return f[(1 << n) - 1];
}
```

---

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿Žè¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿Žè¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµžæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆðŸ˜„~
